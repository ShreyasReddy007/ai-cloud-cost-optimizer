# AI Cloud Cost Optimizer

LLM-driven CLI tool for cloud cost analysis and optimisation in the initial stages of development to understand any scope for improvements during initial stages.

This repository contains a small command-line application that coordinates a set of modules to:

- extract a project profile (LLM-assisted),
- generate mock billing data,
- analyze costs, and
- produce cost-reduction recommendations and a combined optimization report.

---

## Folder Structure (found in the repo)
The repository contains the files and folders described above. (A screenshot of the folder view was provided in the project.)

<img width="356" height="828" alt="Screenshot 2025-12-23 at 23 59 53" src="https://github.com/user-attachments/assets/54934985-5115-4ab7-8acf-1c61df14088c" />

---

## What’s included

Top-level files and folders in this repository:

- `.gitignore` - common ignores (Python artifacts, .env, and outputs/)
- `main.py` - CLI entry point and high-level orchestration of the flow
- `requirements.txt` - dependency manifest (install with pip)
- `analysis/`
  - `cost_analyzer.py` - cost analysis implementation
- `cli/` - CLI helpers (menu rendering; referenced by main.py)
- `llm/` - LLM-related helpers (profile extraction, billing generation, recommendations)
- `utils/` - input/output and report export helpers
- `outputs/` - directory intended to store generated artifacts

---

## Quick overview of the application flow

The application is driven by `main.py`. At runtime it shows a simple menu and supports the following options:

1. Enter project description
   - Prompts for a free-text project description.
   - Saves the description as `project_description.txt`.
   - Calls the LLM-based extractor to create a `project_profile` and saves it as `project_profile.json`.
   - Example input : I want to build an ecommerce analytics platform using React, Node.js and MongoDB. It will be hosted on AWS. My monthly budget is 3000 INR. It should be scalable and cost efficient.

2. Run complete cost analysis
   - Loads `project_profile.json`.
   - Calls the billing generator to create mock billing data and saves it as `mock_billing.json`.
   - Calls the cost analyzer to produce a cost analysis.
   - Calls the recommendations generator (LLM-assisted) to produce recommendations.
   - Combines analysis and recommendations into `cost_optimization_report.json` with a summary that includes:
     - `total_potential_savings` (sum of `potential_savings` from recommendations),
     - `recommendations_count`.

3. View recommendations
   - Loads `cost_optimization_report.json` and prints a short summary:
     - project name, total monthly cost, budget, over-budget flag
     - lists top recommendations (title, service, potential savings, providers).

4. Export report
   - Prompts for export format:
     - HTML (uses `utils.report_exporter.export_html_report`)
     - PDF (uses `utils.pdf_exporter.export_pdf_report`)
   - The exporter functions return a path for the exported file.

5. Exit
   - Quit the program.

Run the application:
```bash
python main.py
```

---

## Implementation detail: analysis/cost_analyzer.py

The cost analyzer implements the function:

analyze_costs(project_profile: dict, billing_data: list) -> dict

Behavior:
- Aggregates costs per service from `billing_data` (expected list of records with at least `"service"` and `"cost_inr"` keys).
- Computes `total_monthly_cost` (sum of all costs).
- Reads `budget_inr_per_month` from the `project_profile` to compute:
  - `budget_variance` = total_cost - budget
  - `is_over_budget` boolean
- Identifies `high_cost_services` as services whose cost is > 30% of total cost.
- Returns a dictionary containing:
  - `total_monthly_cost` (rounded to 2 decimals)
  - `budget`
  - `budget_variance` (rounded)
  - `is_over_budget`
  - `service_costs` (per-service totals)
  - `high_cost_services`

---

## Files created by the run (as used by main.py)

The CLI produces and consumes these JSON/text files in the repository root by default:

- `project_description.txt` — raw user-entered description
- `project_profile.json` — structured profile produced by the profile extractor
- `mock_billing.json` — mock billing data generated by the billing generator
- `cost_optimization_report.json` — final combined report containing:
  - `project_name`
  - `analysis` (output of `analyze_costs`)
  - `recommendations` (LLM-generated list)
  - `summary` (total potential savings, recommendations_count)

The repository also contains an `outputs/` directory (ignored in git) which is intended for export artifacts; exporter functions return paths where they saved HTML/PDF output.

---

## Tech Stack & Dependencies

Recommended runtime:
- Python 3.10+ (recommended for typing and modern stdlib features).  

Dependencies (listed in `requirements.txt`):
- python-dotenv — load environment variables from a .env file
- rich — terminal formatting / pretty printing
- jsonschema — JSON validation utilities
- reportlab — PDF generation (used by PDF exporter)

Install dependencies:
```bash
pip install -r requirements.txt
```

---

## Installation

1. Create and activate a Python virtual environment (recommended):

```bash
python -m venv .venv
# Linux / macOS
source .venv/bin/activate
# Windows (PowerShell)
.venv\Scripts\Activate.ps1
```

2. Install dependencies:

```bash
pip install -r requirements.txt
```

---

## Usage (example session)

1. Start the CLI:

```bash
python main.py
```

2. Choose option `1` to enter your project description. This generates `project_profile.json`.

3. Choose option `2` to run the full pipeline (mock billing -> analysis -> recommendations -> final report). After completion, `cost_optimization_report.json` will be written.

4. Choose option `3` to view a quick summary of recommendations in the terminal.

5. Choose option `4` to export the report to HTML or PDF (if exporter dependencies are available).

6. Choose option `5` to exit.

---

## Tools Used

- ChatGPT 5.2 and Gemini 3 Models
- Used ChatGPT and Gemini to understand project requirements and convert them into a clear implementation plan.
- Used ChatGPT to brainstorm the project structure and architecture before getting into the coding part.
- Used ChatGPT to debug issues regarding billing, recommendation and refine logic during development.
- Used ChatGPT 5.2 and Gemini 3 to improve documentation in readme.md and explanations for the final submission.

---
